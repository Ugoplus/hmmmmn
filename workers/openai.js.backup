// workers/openai.js - Natural AI Conversation (Compatible with Your Bot)

const { Worker } = require('bullmq');
const axios = require('axios');
const redis = require('../config/redis');
const logger = require('../utils/logger');

function parseJSON(raw, fallback = {}) {
  try {
    let cleaned = raw.trim();
    if (cleaned.startsWith('```json')) {
      cleaned = cleaned.replace(/^```json\s*/, '').replace(/\s*```$/, '');
    } else if (cleaned.startsWith('```')) {
      cleaned = cleaned.replace(/^```\s*/, '').replace(/\s*```$/, '');
    }
    return JSON.parse(cleaned);
  } catch (err) {
    logger.error('JSON parse failed:', { raw: raw.substring(0, 200), error: err.message });
    return fallback;
  }
}

// Detect user communication style
async function detectAndStoreUserStyle(userId, message) {
  try {
    // Get message history
    const historyKey = `messages:${userId}`;
    const existingMessages = await redis.get(historyKey);
    let messageHistory = existingMessages ? JSON.parse(existingMessages) : [];
    
    // Add new message
    messageHistory.push(message);
    if (messageHistory.length > 5) messageHistory.shift(); // Keep last 5
    
    // Store updated history
    await redis.set(historyKey, JSON.stringify(messageHistory), 'EX', 86400);
    
    // Detect style if we have enough messages
    if (messageHistory.length >= 2) {
      const text = messageHistory.join(' ').toLowerCase();
      
      const pidginWords = ['abeg', 'wetin', 'dey', 'sabi', 'no wahala', 'how far', 'oya', 'sha', 'nawa', 'comot'];
      const casualWords = ['bro', 'guy', 'lol', 'mehn', 'bros', 'pls'];
      
      let detectedStyle = 'formal';
      if (pidginWords.some(word => text.includes(word))) {
        detectedStyle = 'pidgin';
      } else if (casualWords.some(word => text.includes(word))) {
        detectedStyle = 'casual';
      }
      
      // Store detected style
      await redis.set(`style:${userId}`, detectedStyle, 'EX', 86400 * 7); // Keep for 7 days
      return detectedStyle;
    }
    
    return await redis.get(`style:${userId}`) || 'formal';
  } catch (error) {
    logger.error('Style detection failed', { error: error.message });
    return 'formal';
  }
}

// Enhanced Together AI for natural conversation
async function callTogetherAI(messages) {
  try {
    if (!process.env.TOGETHER_API_KEY || process.env.TOGETHER_API_KEY.trim() === '') {
      throw new Error('TOGETHER_API_KEY not configured');
    }

    const response = await axios.post(
      'https://api.together.xyz/v1/chat/completions',
      {
        model: 'Qwen/Qwen2.5-72B-Instruct-Turbo',
        messages: messages,
        temperature: 0.7,
        max_tokens: 200, // Keep responses short for WhatsApp
        top_p: 0.9
      },
      {
        headers: {
          'Authorization': `Bearer ${process.env.TOGETHER_API_KEY}`,
          'Content-Type': 'application/json'
        },
        timeout: 30000
      }
    );

    return response.data.choices[0].message.content;
    
  } catch (error) {
    logger.error('Together AI failed', { error: error.message });
    throw error;
  }
}

const worker = new Worker(
  'openai-tasks',
  async (job) => {
    try {
      if (job.name === 'parse-query') {
        const { message, userId } = job.data;
        
        logger.info('Processing natural conversation query', { 
          userId, 
          messageLength: message?.length 
        });

        // Detect and store user style
        const userStyle = await detectAndStoreUserStyle(userId, message);

        // Check if job-related (keep your existing logic)
        const text = message.toLowerCase();
        const jobKeywords = [
          'job', 'work', 'career', 'employment', 'position', 'role', 
          'cv', 'resume', 'apply', 'interview', 'skill', 'experience',
          'remote', 'office', 'company', 'developer', 'engineer', 'manager',
          'tech', 'business', 'finance', 'marketing', 'sales',
          'lagos', 'abuja', 'nigeria', 'find', 'search', 'help', 'hello'
        ];
        
        const isJobRelated = jobKeywords.some(keyword => text.includes(keyword)) || text.length < 20;
        
        if (!isJobRelated) {
          const outOfScopeResponses = {
            pidgin: "I only dey help with work matter o. Wetin work you dey find?",
            casual: "I only help with job stuff. What work you looking for?",
            formal: "I only assist with job-related matters. What position are you seeking?"
          };
          
          return {
            action: 'out_of_scope',
            response: outOfScopeResponses[userStyle] || outOfScopeResponses.formal
          };
        }

        // Use AI for natural conversation
        if (process.env.TOGETHER_API_KEY) {
          try {
            const systemPrompt = createNaturalConversationPrompt(userStyle);
            
            const prompt = [
              { role: 'system', content: systemPrompt },
              { role: 'user', content: message }
            ];

            const result = await callTogetherAI(prompt);
            const parsedResult = parseJSON(result, null);
            
            if (parsedResult && parsedResult.action) {
              logger.info('AI generated response', { 
                action: parsedResult.action, 
                userStyle 
              });
              return parsedResult;
            }
            
          } catch (aiError) {
            logger.warn('AI failed, using smart fallback', { error: aiError.message });
          }
        }

        // Smart fallback when AI fails
        return generateSmartFallback(message, userStyle);

      } else if (job.name === 'analyze-cv') {
        // Keep your existing CV analysis logic exactly as is
        const { cvText, jobTitle } = job.data;
        
        if (!cvText) {
          return {
            overall_score: 0,
            job_match_score: 0,
            skills_score: 0,
            experience_score: 0,
            education_score: 0,
            experience_years: 0,
            summary: 'No CV text provided for analysis'
          };
        }

        if (process.env.TOGETHER_API_KEY) {
          try {
            const prompt = [
              {
                role: 'system',
                content: `You are a Nigerian HR expert. Analyze this CV and return JSON:
                {
                  "overall_score": number (0-100),
                  "job_match_score": number (0-100),
                  "skills_score": number (0-100),
                  "experience_score": number (0-100),
                  "education_score": number (0-100),
                  "experience_years": number,
                  "key_skills": ["skill1", "skill2", "skill3"],
                  "relevant_skills": ["relevant1", "relevant2"],
                  "education_level": "Bachelor's|Master's|PhD|Diploma|Secondary|Other",
                  "summary": "brief professional summary",
                  "strengths": ["strength1", "strength2", "strength3"],
                  "areas_for_improvement": ["area1", "area2"],
                  "recommendation": "Strong|Good|Average|Weak",
                  "cv_quality": "Excellent|Good|Average|Poor"
                }

                Focus on Nigerian job market standards. Be honest but encouraging.`
              },
              { 
                role: 'user', 
                content: `Analyze this CV${jobTitle ? ` for ${jobTitle} position` : ''}:\n\n${cvText.substring(0, 1500)}` 
              }
            ];

            const result = await callTogetherAI(prompt);
            const analysis = parseJSON(result, null);
            
            if (analysis && analysis.overall_score) {
              return analysis;
            }
          } catch (error) {
            logger.error('AI CV analysis failed', { error: error.message });
          }
        }

        // Fallback analysis (your existing logic)
        return performFallbackCVAnalysis(cvText, jobTitle);

      } else if (job.name === 'generate-cover-letter') {
        // Keep professional cover letters always
        const { cvText } = job.data;
        
        if (process.env.TOGETHER_API_KEY) {
          try {
            const prompt = [
              {
                role: 'system',
                content: `Write a professional cover letter for a Nigerian job application. 150-200 words. Always use formal English regardless of user's communication style.`
              },
              { role: 'user', content: `Cover letter based on: ${cvText.substring(0, 1000)}` }
            ];

            const result = await callTogetherAI(prompt);
            return result;
          } catch (error) {
            logger.warn('Cover letter generation failed, using fallback');
          }
        }

        // Professional fallback
        return `Dear Hiring Manager,

I am writing to express my strong interest in this position. My background and professional experience make me well-qualified for this role.

I am confident that my skills and expertise would be valuable assets to your organization. I have demonstrated success in delivering results and collaborating effectively in professional environments.

I would welcome the opportunity to discuss how my experience can contribute to your team's continued success. Thank you for your consideration, and I look forward to hearing from you.

Best regards,
[Your Name]`;
      }

    } catch (error) {
      logger.error('Natural AI worker job failed', { error: error.message });
      return { 
        action: 'error', 
        response: 'Something went wrong. Please try again.'
      };
    }
  },
  { 
    connection: redis, 
    concurrency: 3 
  }
);

// Create natural conversation prompt
function createNaturalConversationPrompt(userStyle) {
  const styleGuide = {
    pidgin: "Respond in Nigerian pidgin English. Use words like 'wetin', 'dey', 'sabi', 'no wahala'. Be friendly and brief (max 30 words).",
    casual: "Use casual Nigerian English. Say 'guy', 'bro', use contractions. Keep it friendly and short (max 30 words).",
    formal: "Use professional Nigerian English. Be respectful and clear. Keep responses brief (max 30 words)."
  };

  return `You are SmartCVNaija, a helpful Nigerian job search assistant.

PERSONALITY: ${styleGuide[userStyle]}

YOUR JOB: Help users find jobs in Nigeria. Users must pay â‚¦500 for 10 daily applications.

CORE ACTIONS YOU CAN TAKE:
- "greeting" - Welcome new users
- "search_jobs" - When they want to find jobs  
- "apply_job" - When they want to apply to jobs
- "help" - When they need guidance
- "status" - When they ask about their usage
- "unknown" - When you're not sure

RESPONSE RULES:
1. Keep responses under 30 words
2. Be helpful and direct
3. Always return valid JSON
4. Match the user's communication style

RESPONSE FORMAT (JSON):
{
  "action": "greeting|search_jobs|apply_job|help|status|unknown",
  "response": "your brief response matching user style",
  "filters": {"title": "job type", "location": "city", "remote": true/false},
  "applyAll": true/false,
  "jobNumbers": [1,2,3] or null
}

EXAMPLES:
User: "Hello" â†’ {"action": "greeting", "response": "How far! I help you find work for Nigeria. Wetin you need?"}
User: "I need developer work in Lagos" â†’ {"action": "search_jobs", "response": "Searching developer jobs for Lagos...", "filters": {"title": "developer", "location": "Lagos"}}
User: "apply to all jobs" â†’ {"action": "apply_job", "response": "Applying to all jobs...", "applyAll": true}

Be natural, helpful, and brief!`;
}

// Smart fallback when AI fails
function generateSmartFallback(message, userStyle) {
  const text = message.toLowerCase();
  
  const responses = {
    pidgin: {
      greeting: "How far! I dey help you find work. Wetin you need?",
      search: "Which kind work you dey find?",
      apply: "You wan apply for job? Upload CV first.",
      help: "I fit help you find work for Naija. Talk wetin you need."
    },
    casual: {
      greeting: "Hey! I help you find jobs. What you need?",
      search: "What kind of job you looking for?", 
      apply: "Want to apply? Upload your CV first.",
      help: "I help you find jobs in Nigeria. What you need?"
    },
    formal: {
      greeting: "Hello! I assist with job searches. How may I help?",
      search: "What type of position are you seeking?",
      apply: "To apply, please upload your CV first.",
      help: "I assist with job searches in Nigeria. How may I help?"
    }
  };

  const styleResponses = responses[userStyle] || responses.formal;

  // Determine intent from message
  if (text.includes('hello') || text.includes('hi') || text.includes('hey')) {
    return { action: 'greeting', response: styleResponses.greeting };
  }
  
  if (text.includes('job') || text.includes('work') || text.includes('find')) {
    const filters = {};
    
    // Extract location
    if (text.includes('lagos')) filters.location = 'Lagos';
    if (text.includes('abuja')) filters.location = 'Abuja';
    if (text.includes('remote')) filters.remote = true;
    
    // Extract job type
    if (text.includes('developer')) filters.title = 'developer';
    if (text.includes('designer')) filters.title = 'designer';
    if (text.includes('manager')) filters.title = 'manager';
    if (text.includes('marketing')) filters.title = 'marketing';
    
    return { 
      action: 'search_jobs', 
      response: styleResponses.search,
      filters: filters
    };
  }
  
  if (text.includes('apply')) {
    const jobNumbers = [];
    const matches = text.match(/\b(\d+)\b/g);
    if (matches) {
      jobNumbers.push(...matches.map(n => parseInt(n)).filter(n => n > 0 && n <= 10));
    }
    
    return {
      action: 'apply_job',
      response: styleResponses.apply,
      applyAll: text.includes('all'),
      jobNumbers: jobNumbers.length > 0 ? jobNumbers : null
    };
  }
  
  return { action: 'help', response: styleResponses.help };
}

// Fallback CV analysis (keep your existing logic)
function performFallbackCVAnalysis(cvText, jobTitle = null) {
  const text = cvText.toLowerCase();
  let overallScore = 50;
  let jobMatchScore = 50;

  // Basic skills analysis
  const techSkills = ['javascript', 'python', 'java', 'react', 'node', 'sql', 'html', 'css'];
  const foundSkills = [];
  
  techSkills.forEach(skill => {
    if (text.includes(skill)) {
      foundSkills.push(skill);
      overallScore += 3;
    }
  });

  // Experience estimation
  const experienceYears = extractExperienceYears(text);
  const experienceScore = Math.min(experienceYears * 10, 100);
  
  if (experienceYears >= 5) overallScore += 10;
  if (experienceYears >= 3) overallScore += 5;

  let educationLevel = 'Other';
  let educationScore = 50;
  
  if (text.includes('phd')) {
    educationScore = 100;
    educationLevel = 'PhD';
  } else if (text.includes('master') || text.includes('msc')) {
    educationScore = 85;
    educationLevel = 'Master\'s';
  } else if (text.includes('bachelor') || text.includes('bsc')) {
    educationScore = 75;
    educationLevel = 'Bachelor\'s';
  }

  return {
    overall_score: Math.min(Math.max(overallScore, 0), 100),
    job_match_score: Math.min(Math.max(jobMatchScore, 0), 100),
    skills_score: Math.min(foundSkills.length * 8, 100),
    experience_score: experienceScore,
    education_score: educationScore,
    experience_years: experienceYears,
    key_skills: foundSkills.slice(0, 5),
    relevant_skills: foundSkills.slice(0, 3),
    education_level: educationLevel,
    summary: `Professional with ${experienceYears} years experience`,
    strengths: ["Technical skills", "Professional experience"],
    areas_for_improvement: ["CV formatting", "Additional certifications"],
    recommendation: overallScore >= 70 ? 'Strong' : overallScore >= 50 ? 'Good' : 'Average',
    cv_quality: overallScore >= 75 ? 'Good' : 'Average'
  };
}

function extractExperienceYears(text) {
  const patterns = [
    /(\d+)\s*years?\s*(of\s*)?experience/i,
    /(\d+)\s*yrs?\s*(of\s*)?experience/i,
    /experience.*?(\d+)\s*years?/i
  ];

  for (const pattern of patterns) {
    const match = text.match(pattern);
    if (match) {
      return parseInt(match[1]);
    }
  }

  // Estimate from job history
  const jobCount = (text.match(/\b(19|20)\d{2}\b/g) || []).length;
  return Math.max(Math.floor(jobCount / 2), 0);
}

// Event handlers
worker.on('ready', () => {
  logger.info('Natural AI conversation worker ready! ðŸ¤–');
});

worker.on('completed', (job, result) => {
  logger.info('Natural conversation completed', { 
    jobId: job.id, 
    action: result?.action 
  });
});

worker.on('failed', (job, err) => {
  logger.error('Natural conversation failed', { jobId: job.id, error: err.message });
});

logger.info('SmartCVNaija natural AI worker started! ðŸš€');

module.exports = worker;
